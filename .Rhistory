# Function to calculate CV for a vector of values
calculate_cv <- function(values) {
if (length(values) > 0 && mean(values) != 0) {
return(sd(values) / abs(mean(values)))
} else {
return(NA)
}
}
# Data frame to store results
results_masked <- data.frame(subplot_id = character(), band = integer(), CV = numeric(), stringsAsFactors = FALSE)
# Loop through each subplot
for (i in 1:nrow(subplot_dimensions)) {
subplot_id <- subplot_dimensions$subplot_id[i]
min_x <- subplot_dimensions$Min_x_coord[i]
max_x <- subplot_dimensions$Max_x_coord[i]
min_y <- subplot_dimensions$Min_y_coord[i]
max_y <- subplot_dimensions$Max_y_coord[i]
# Extract pixel values
pixel_values_m <- extract_pixel_values_m(raster_data_masked, min_x, max_x, min_y, max_y)
# Calculate CV for each band
for (band in 1:ncol(pixel_values_m)) {
values <- pixel_values_m[, band]
cv_value <- calculate_cv(values)
# Store the result
results_masked <- rbind(results_masked, data.frame(subplot_id = subplot_id, band = band, CV = cv_value))
}
}
# Print the results
print(results_masked)
View(results)
cons_ss_2 <- rast('biodivmapR/RESULTS/cons_reflectance_combined_image_2/SPCA/SpectralSpecies/SpectralSpecies.tif')
setwd("C:/Users/adele/Documents/fowlers_veg_timeline")
cons_ss_2 <- rast('biodivmapR/RESULTS/cons_reflectance_combined_image_2/SPCA/SpectralSpecies/SpectralSpecies.tif')
cons_ss_2 <- rast('biodivmapR/RESULTS/cons_reflectance_combined_image_2/SPCA/SpectralSpecies/SpectralSpecies.tif')
cons_ss_2 <- rast('biodivmapR/RESULTS/cons_reflectance_combined_image_2/SPCA/SpectralSpecies/SpectralSpecies.tif')
cons_ss_2 <- rast('biodivmapR/RESULTS/cons_reflectance_combined_image_2/SPCA/SpectralSpecies/SpectralSpecies.tif')
plot(cons_ss_2[[3]])
plot(cons_ss[[3]])
plot(cons_ss_2)
cons_ss_2 <- rast('biodivmapR/RESULTS/cons_reflectance_combined_image_2/SPCA/SpectralSpecies/SpectralSpecies.tif')
plot(cons_ss_2[[3]])
tmpdir <- 'C:/Users/adele/Documents/fowlers_veg_timeline/ENVI'
NameRaster <- 'cons_reflectance_combined_image'
destfiletiff <- file.path(tmpdir,NameRaster)
Input_Image_File <- destfiletiff
# Set to FALSE if no mask available
Input_Mask_File <- FALSE
Output_Dir <- 'C:/Users/adele/Documents/fowlers_veg_timeline/biodivmapR/RESULTS'
NDVI_Thresh <- 0.05
Blue_Thresh <- 1500/10000
NIR_Thresh <- 0.02
# continuum removal is a normalisation procedure which reduces multiplicative effects
Continuum_Removal <- TRUE
TypePCA <- 'SPCA'
# PCA FILTERING:        Set to TRUE if you want second filtering based on PCA outliers to be processed.
# Slower process
# Automatically set to FALSE if TypePCA     = 'MNF'
FilterPCA <- TRUE
window_size <- 100
nbCPU <- 10
MaxRAM <- 0.5
# number of clusters
nbclusters <- 20
Excluded_WL <- NA
Input_Mask_File <- perform_radiometric_filtering(Image_Path = Input_Image_File, Mask_Path = Input_Mask_File,
Output_Dir = Output_Dir, TypePCA = TypePCA,
NDVI_Thresh = NDVI_Thresh, Blue_Thresh = Blue_Thresh,
NIR_Thresh = NIR_Thresh,
Blue = 450,
Red = 650,
NIR = 840)
PCA_Output <- perform_PCA(Input_Image_File = Input_Image_File,
Input_Mask_File = Input_Mask_File,
Output_Dir = Output_Dir,
TypePCA = TypePCA,
FilterPCA = FilterPCA,
nbCPU = nbCPU,
MaxRAM = MaxRAM,
Continuum_Removal = Continuum_Removal)
# path of the raster resulting from dimensionality reduction
PCA_Files <- PCA_Output$PCA_Files
# path for the updated mask
Input_Mask_File <- PCA_Output$MaskPath
Sel_PC <- select_PCA_components(Input_Image_File = Input_Image_File,
Output_Dir = Output_Dir,
PCA_Files = PCA_Output$PCA_Files,
TypePCA = PCA_Output$TypePCA,
File_Open = TRUE)
Input_Mask_File = Input_Mask_File,
Kmeans_info <- map_spectral_species(Input_Image_File = Input_Image_File,
Input_Mask_File = Input_Mask_File,
Output_Dir = Output_Dir,
SpectralSpace_Output = PCA_Output,
nbclusters = nbclusters,
nbCPU = nbCPU, MaxRAM = MaxRAM)
Index_Alpha <- c('Shannon')
window_size <- 100
map_alpha_div(Input_Image_File = Input_Image_File,
Output_Dir = Output_Dir,
TypePCA = TypePCA,
window_size = window_size,
nbCPU = nbCPU,
MaxRAM = MaxRAM,
Index_Alpha = Index_Alpha,
nbclusters = nbclusters)
library(ausplotsR)
# co-efficient of variance metrics ------------------------------------------------
# read in subplot dimensions
subplot_dimensions <- read.csv('data/cons_fishnet_simpson_nd0.csv') %>%
dplyr::select(c(1:3, 6, 15:20))
# generate subplot IDs
subplot_ids <- unlist(lapply(1:5, function(i) paste(i, 1:5, sep="_")))
# co-efficient of variance metrics ------------------------------------------------
# read in subplot dimensions
library(tidyverse)
subplot_dimensions <- read.csv('data/cons_fishnet_simpson_nd0.csv') %>%
dplyr::select(c(1:3, 6, 15:20))
subplot_dimensions <- read.csv('data/cons_fishnet_simpson_nd0.csv') %>%
dplyr::select(c(1:3, 6, 15:20))
# generate subplot IDs
subplot_ids <- unlist(lapply(1:5, function(i) paste(i, 1:5, sep="_")))
subplot_dimensions <- subplot_dimensions %>% mutate(subplot_id = subplot_ids)
# load raster
raster_data <- stack('data_out/cons_reflectance_combined_image.tif')
setwd("C:/Users/adele/Documents/fowlers_veg_timeline")
# load raster
raster_data <- stack('data_out/cons_reflectance_combined_image.tif')
# co-efficient of variance metrics ------------------------------------------------
# read in subplot dimensions
library(terra)
# co-efficient of variance metrics ------------------------------------------------
# read in subplot dimensions
library(raster)
# load raster
raster_data <- stack('data_out/cons_reflectance_combined_image.tif')
# Function to extract pixel values for each band within the specified extent
# Function to extract pixel values from a raster within specified extents
extract_pixel_values_m <- function(raster_data_masked, min_x, max_x, min_y, max_y) {
# Define the extent
ex <- extent(min_x, max_x, min_y, max_y)
# Crop the raster to the extent
cropped_raster_m <- crop(raster_data_masked, ex)
# Extract pixel values for each band
pixel_values_m <- as.data.frame(getValues(cropped_raster_m))
# Remove rows with NA values
pixel_values_m <- na.omit(pixel_values_m)
return(pixel_values_m)
}
# Function to calculate CV for a vector of values
calculate_cv <- function(values) {
if (length(values) > 0 && mean(values) != 0) {
return(sd(values) / abs(mean(values)))
} else {
return(NA)
}
}
# Data frame to store results
results_masked <- data.frame(subplot_id = character(), CV = numeric(), stringsAsFactors = FALSE)
# Loop through each subplot
for (i in 1:nrow(subplot_dimensions)) {
subplot_id <- subplot_dimensions$subplot_id[i]
min_x <- subplot_dimensions$Min_x_coord[i]
max_x <- subplot_dimensions$Max_x_coord[i]
min_y <- subplot_dimensions$Min_y_coord[i]
max_y <- subplot_dimensions$Max_y_coord[i]
# Extract pixel values
pixel_values_m <- extract_pixel_values_m(raster_data_masked, min_x, max_x, min_y, max_y)
# Calculate CV for each band
cv_values <- numeric()
for (band in 1:ncol(pixel_values_m)) {
values <- pixel_values_m[, band]
cv_value <- calculate_cv(values)
cv_values <- c(cv_values, cv_value)
}
# Calculate overall CV for the subplot
valid_cvs <- cv_values[!is.na(cv_values)]
overall_cv <- if (length(valid_cvs) > 0) {
sum(valid_cvs) / length(valid_cvs)
} else {
NA
}
# Store the result
results_masked <- rbind(results_masked, data.frame(subplot_id = subplot_id, CV = overall_cv))
}
# Load the mask and raster data
mask <- read_stars('biodivmapR/RESULTS/cons_reflectance_combined_image_2/SPCA/ShadeMask_Update')
mask_raster <- as(mask, "Raster")
mask_raster[mask_raster == 0] <- NA
raster_data <- stack('data_out/cons_reflectance_combined_image.tif')
raster_data_masked <- mask(raster_data, mask_raster)
## NOW FOR THE MASKED RASTER
library(raster)
library(dplyr)
library(stars)
# Load the mask and raster data
mask <- read_stars('biodivmapR/RESULTS/cons_reflectance_combined_image_2/SPCA/ShadeMask_Update')
mask_raster <- as(mask, "Raster")
mask_raster[mask_raster == 0] <- NA
raster_data <- stack('data_out/cons_reflectance_combined_image.tif')
raster_data_masked <- mask(raster_data, mask_raster)
# Read the subplot dimensions and select necessary columns
subplot_dimensions <- read.csv('data/cons_fishnet_simpson_nd0.csv') %>%
dplyr::select(c(1:3, 6, 15:20))
# Generate subplot IDs
subplot_ids <- unlist(lapply(1:5, function(i) paste(i, 1:5, sep="_")))
subplot_dimensions <- subplot_dimensions %>% mutate(subplot_id = subplot_ids)
# Function to extract pixel values for each band within the specified extent
# Function to extract pixel values from a raster within specified extents
extract_pixel_values_m <- function(raster_data_masked, min_x, max_x, min_y, max_y) {
# Define the extent
ex <- extent(min_x, max_x, min_y, max_y)
# Crop the raster to the extent
cropped_raster_m <- crop(raster_data_masked, ex)
# Extract pixel values for each band
pixel_values_m <- as.data.frame(getValues(cropped_raster_m))
# Remove rows with NA values
pixel_values_m <- na.omit(pixel_values_m)
return(pixel_values_m)
}
# Function to calculate CV for a vector of values
calculate_cv <- function(values) {
if (length(values) > 0 && mean(values) != 0) {
return(sd(values) / abs(mean(values)))
} else {
return(NA)
}
}
# Data frame to store results
results_masked <- data.frame(subplot_id = character(), CV = numeric(), stringsAsFactors = FALSE)
# Loop through each subplot
for (i in 1:nrow(subplot_dimensions)) {
subplot_id <- subplot_dimensions$subplot_id[i]
min_x <- subplot_dimensions$Min_x_coord[i]
max_x <- subplot_dimensions$Max_x_coord[i]
min_y <- subplot_dimensions$Min_y_coord[i]
max_y <- subplot_dimensions$Max_y_coord[i]
# Extract pixel values
pixel_values_m <- extract_pixel_values_m(raster_data_masked, min_x, max_x, min_y, max_y)
# Calculate CV for each band
cv_values <- numeric()
for (band in 1:ncol(pixel_values_m)) {
values <- pixel_values_m[, band]
cv_value <- calculate_cv(values)
cv_values <- c(cv_values, cv_value)
}
# Calculate overall CV for the subplot
valid_cvs <- cv_values[!is.na(cv_values)]
overall_cv <- if (length(valid_cvs) > 0) {
sum(valid_cvs) / length(valid_cvs)
} else {
NA
}
# Store the result
results_masked <- rbind(results_masked, data.frame(subplot_id = subplot_id, CV = overall_cv))
}
View(results_masked)
# Function to extract pixel values for each band within the specified extent
extract_pixel_values <- function(raster_data, min_x, max_x, min_y, max_y) {
# Define the extent
ex <- extent(min_x, max_x, min_y, max_y)
# Crop the raster to the extent
cropped_raster <- crop(raster_data, ex)
# Extract pixel values for each band
pixel_values <- as.data.frame(getValues(cropped_raster))
# Remove rows with NA values
pixel_values <- na.omit(pixel_values)
return(pixel_values)
}
# Function to calculate CV for a vector of values
calculate_cv <- function(values) {
if (length(values) > 0 && mean(values) != 0) {
return(sd(values) / abs(mean(values)))
} else {
return(NA)
}
}
# Data frame to store results
results <- data.frame(subplot_id = character(), CV = numeric(), stringsAsFactors = FALSE)
# Loop through each subplot
for (i in 1:nrow(subplot_dimensions)) {
subplot_id <- subplot_dimensions$subplot_id[i]
min_x <- subplot_dimensions$Min_x_coord[i]
max_x <- subplot_dimensions$Max_x_coord[i]
min_y <- subplot_dimensions$Min_y_coord[i]
max_y <- subplot_dimensions$Max_y_coord[i]
# Extract pixel values
pixel_values <- extract_pixel_values(raster_data, min_x, max_x, min_y, max_y)
# Calculate CV for each band
cv_values <- numeric()
for (band in 1:ncol(pixel_values)) {
values <- pixel_values[, band]
cv_value <- calculate_cv(values)
cv_values <- c(cv_values, cv_value)
}
# Calculate overall CV for the subplot
valid_cvs <- cv_values[!is.na(cv_values)]
overall_cv <- if (length(valid_cvs) > 0) {
sum(valid_cvs) / length(valid_cvs)
} else {
NA
}
# Store the result
results <- rbind(results, data.frame(subplot_id = subplot_id, CV = overall_cv))
}
View(results_masked)
View(results)
View(results_masked)
View(results)
View(results_masked)
survey_data <- read.csv('data/ausplots_march_24.csv')
cons_survey_data <- survey_data %>%
filter(site_unique == 'NSABHC012')
# Extract only direction of the transect (no numbers)
cons_survey_data$transect_direction <- gsub('[[:digit:]]+', '', cons_survey_data$transect)
# Extract only number of the transect (no direction)
cons_survey_data$transect_number <- as.numeric(gsub(".*?([0-9]+).*", "\\1", cons_survey_data$transect))
# Create variable for fixed transect direction (to order them all transects in the same direction)
cons_survey_data$transect_direction2 <- NA
# Create variable for fixed point number (inverse in some cases as if they had been collected in the same direction)
cons_survey_data$point_number2 <- NA
# Create XY empty variables for plot XY coordinates
cons_survey_data$X_plot <- NA
cons_survey_data$Y_plot <- NA
# For loop to homogenize transects and numbers. It converts all E-W to W-E and all S-N to N-S
for (i in 1:nrow(cons_survey_data)){
if (cons_survey_data[i, "transect_direction"] == "E-W") {
cons_survey_data[i, "point_number2"] <- 100 - cons_survey_data[i, "point_number"] # If transect E-W, transect fixed is W-E and inverse numbers
cons_survey_data[i, "transect_direction2"] <- "W-E"
}
if (cons_survey_data[i, "transect_direction"] == "W-E") {
cons_survey_data[i, "point_number2"] <- cons_survey_data[i, "point_number"] # If transect W-E, all stays the same
cons_survey_data[i, "transect_direction2"] <- "W-E"
}
if (cons_survey_data[i, "transect_direction"] == "N-S") {
cons_survey_data[i, "point_number2"] <- cons_survey_data[i, "point_number"] # If transect N-S, all stays the same
cons_survey_data[i, "transect_direction2"] <- "N-S"
}
if (cons_survey_data[i, "transect_direction"] == "S-N") {
cons_survey_data[i, "point_number2"] <- 100 - cons_survey_data[i, "point_number"] # If transect S-N, transect fixed is N-S and inverse numbers
cons_survey_data[i, "transect_direction2"] <- "N-S"
}
}
# For loop to assign plotXY coordinates to each point intercept
for (i in 1:nrow(cons_survey_data)){
if (cons_survey_data[i, "transect_direction2"] == "W-E") {
if (cons_survey_data[i, "transect_number"] == 1){
cons_survey_data[i, "Y_plot"] <- 10
cons_survey_data[i, "X_plot"] <- cons_survey_data[i, "point_number2"]
}
if (cons_survey_data[i, "transect_number"] == 2){
cons_survey_data[i, "Y_plot"] <- 30
cons_survey_data[i, "X_plot"] <- cons_survey_data[i, "point_number2"]
}
if (cons_survey_data[i, "transect_number"] == 3){
cons_survey_data[i, "Y_plot"] <- 50
cons_survey_data[i, "X_plot"] <- cons_survey_data[i, "point_number2"]
}
if (cons_survey_data[i, "transect_number"] == 4){
cons_survey_data[i, "Y_plot"] <- 70
cons_survey_data[i, "X_plot"] <- cons_survey_data[i, "point_number2"]
}
if (cons_survey_data[i, "transect_number"] == 5){
cons_survey_data[i, "Y_plot"] <- 90
cons_survey_data[i, "X_plot"] <- cons_survey_data[i, "point_number2"]
}
}
if (cons_survey_data[i, "transect_direction2"] == "N-S") {
if (cons_survey_data[i, "transect_number"] == 1){
cons_survey_data[i, "X_plot"] <- 10
cons_survey_data[i, "Y_plot"] <- cons_survey_data[i, "point_number2"]
}
if (cons_survey_data[i, "transect_number"] == 2){
cons_survey_data[i, "X_plot"] <- 30
cons_survey_data[i, "Y_plot"] <- cons_survey_data[i, "point_number2"]
}
if (cons_survey_data[i, "transect_number"] == 3){
cons_survey_data[i, "X_plot"] <- 50
cons_survey_data[i, "Y_plot"] <- cons_survey_data[i, "point_number2"]
}
if (cons_survey_data[i, "transect_number"] == 4){
cons_survey_data[i, "X_plot"] <- 70
cons_survey_data[i, "Y_plot"] <- cons_survey_data[i, "point_number2"]
}
if (cons_survey_data[i, "transect_number"] == 5){
cons_survey_data[i, "X_plot"] <- 90
cons_survey_data[i, "Y_plot"] <- cons_survey_data[i, "point_number2"]
}
}
}
cons_survey_data %>%
drop_na(standardised_name) %>%
ggplot(aes(x = X_plot, y = Y_plot, color = growth_form)) +
geom_point() +
theme_classic()
cons_survey_data$subplot_row <- pmin(ceiling((cons_survey_data$Y_plot + 1) / 20), 5)
cons_survey_data$subplot_col <- pmin(ceiling((cons_survey_data$X_plot + 1) / 20), 5)
# single ID for subplot row and column
cons_survey_data$subplot_id <- paste(cons_survey_data$subplot_row, cons_survey_data$subplot_col, sep = "_")
subplot_diversity <- cons_survey_data %>%
drop_na(standardised_name) %>%
group_by(subplot_id) %>%
summarise(species_richness = n_distinct(standardised_name))
community_matrix <- cons_survey_data %>%
drop_na(standardised_name) %>%
count(subplot_id, standardised_name) %>%
spread(standardised_name, n, fill = 0)
#column V1? what is zis???
if ("V1" %in% colnames(community_matrix)) {
community_matrix <- community_matrix %>%
dplyr::select(-V1)
}
# calculate diversity indices
shannon_diversity <- diversity(community_matrix[, -1], index = "shannon")
simpson_diversity <- diversity(community_matrix[, -1], index = "simpson")
library(vegan)
# calculate diversity indices
shannon_diversity <- diversity(community_matrix[, -1], index = "shannon")
simpson_diversity <- diversity(community_matrix[, -1], index = "simpson")
#read in biodivmapR values from arcgis table
cons_simpson_biodivmapR <- read.csv('data/cons_fishnet_simpson_nd0.csv') %>%
dplyr::select(10)
cons_shannon_biodivmapR <- read.csv('data/shannon_nd0_cons.csv') %>%
dplyr::select(7)
#read in biodivmapR values from arcgis table for NON MASKED raster
cons_nm_simpson_biodivmapR <- read.csv('data/simpson_not_masked_cons.csv') %>%
dplyr::select(16)
cons_nm_shannon_biodivmapR <- read.csv('data/shannon_not_masked_cons.csv') %>%
dplyr::select(16)
subplot_diversity <- subplot_diversity %>%
mutate(
shannon_diversity = shannon_diversity,
simpson_diversity = simpson_diversity,
cv = results$CV,
cv_masked = results_masked$CV,
shannon_biodivmapR = cons_shannon_biodivmapR$MEAN,
simpson_biodivmapR = cons_simpson_biodivmapR$MEAN,
shannon_non_mask_biodivmapR = cons_nm_shannon_biodivmapR$MEAN,
simspon_non_mask_biodivmapR = cons_nm_simpson_biodivmapR$MEAN
)
subplot_coordinates <- cons_survey_data %>%
dplyr::select(subplot_id, X_plot, Y_plot) %>%
distinct()
# merge coords
subplot_diversity_c <- subplot_diversity %>%
left_join(subplot_coordinates, by = "subplot_id")
#plot # of plant obs as size
df_long <- subplot_diversity %>%
dplyr::select(shannon_diversity, shannon_biodivmapR, shannon_non_mask_biodivmapR) %>%
pivot_longer(cols = c(shannon_biodivmapR, shannon_non_mask_biodivmapR),
names_to = "variable",
values_to = "value")
#shannons compared
ggplot(df_long, aes(x = shannon_diversity, y = value, color = variable)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE) +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black") +
labs(x = "Shannon Diversity", y = "Value") +
theme_minimal()
cv_long <- subplot_diversity %>%
select(shannon_diversity, cv, cv_masked) %>%
pivot_longer(cols = c(cv, cv_masked),
names_to = "variable",
values_to = "value")
cv_long <- subplot_diversity %>%
select(shannon_diversity, cv, cv_masked) %>%
pivot_longer(cols = c(cv, cv_masked),
names_to = "variable",
values_to = "value")
library(sf)
library(tidyverse)
library(raster)
cv_long <- subplot_diversity %>%
dplyr::select(shannon_diversity, cv, cv_masked) %>%
pivot_longer(cols = c(cv, cv_masked),
names_to = "variable",
values_to = "value")
ggplot(cv_long, aes(x = shannon_diversity, y = value, color = variable, group = variable)) +
geom_point() +
geom_smooth(method = 'lm', se = F) +
labs(x = "Shannon Diversity", y = "CV value") +
theme_minimal()
model <- lm(cv ~ shannon_diversity, data = subplot_diversity)
summary(model)
cor_test <- cor.test(subplot_diversity$shannon_diversity, subplot_diversity$cv_masked)
cor_test$estimate
model <- lm(cv_masked ~ shannon_diversity, data = subplot_diversity)
summary(model)
cor_test <- cor.test(subplot_diversity$shannon_diversity, subplot_diversity$cv)
cor_test$estimate
View(subplot_dimensions)
subplot_dimensions <- read.csv('data/cons_fishnet_simpson_nd0.csv') %>%
dplyr::select(c(1:3, 6, 15:20))
View(subplot_dimensions)
# generate subplot IDs
subplot_ids <- unlist(lapply(1:5, function(i) paste(i, 1:5, sep="_")))
subplot_dimensions <- subplot_dimensions %>% mutate(subplot_id = subplot_ids)
# file directory
mosaics_dir <- "data/2024_mosaics"
# folder list
folders <- list.dirs(mosaics_dir, full.names = FALSE)
# folder list
folders <- list.dirs(mosaics_dir, full.names = FALSE)
folders <- list.dirs(mosaics_dir)
# folder list
folders <- list.dirs(mosaics_dir, full.names = FALSE)
folders <- folders[folders != c("","point_clouds"]
folders <- folders[folders != c("","point_clouds")]
?list.dirs
# folder list
folders <- list.dirs(mosaics_dir, full.names = FALSE, all.files = FALSE)
# folder list
folders <- list.dirs(mosaics_dir, full.names = FALSE, include.dirs = FALSE)
