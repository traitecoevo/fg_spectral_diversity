---
title: "Introduction to for loops in R"
author: "Will Cornwell, Daniel Falster"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

# Introduction

The goal of this prac is to learn to get the computer to repeat things for you and therefore avoid tedium and burnout and stay a happy PhD student with a obedient computer rather than a frustrated, burned-out one with RSI. 
```{r}
library(tidyverse)

for (current_number in c(3, 7, 3)) {
  print(current_number)
}
5 + 3

c(3, 7, 3)[2]


letters
```

# Your first for-loop

There are datasets in R already.  one of them is called `letters`.  It does this

```{r}
letters

LETTERS
```

keep this in mind for the tasks below.

**Exercises:**
1. Write a `for` loop that prints out each letter sequentially through the alphabet

```{r}
for (current_letter in letters){
  print(current_letter)
}

```

2. (stretch) Write a `for` loop that prints out every letter except `q`.  never liked `q` anyway.  

```{r}

for (current_letter in letters) {
  if (current_letter != 'q') {
    print(current_letter)
  }
}
 
```


Now some fun code (which will also be useful later). This code makes a plot of the world.  You can see that it's just a `ggplot` call with a `geom_polygon` added.  Then the `coord_fixed` call is just scaling x relative y so that the world is not distorted.  This is a common thing to do with maps.

```{r}
library(ggplot2)
world <- map_data("world")
australia <- map_data("world", region = "Australia")

ggplot() +
  geom_polygon(data = world, aes(x = long, y = lat, group = group)) +
  coord_fixed(1.3)

ggplot() +
  geom_polygon(data = australia, aes(x = long, y = lat, group = group)) +
  coord_fixed(1.3)

```

Note that we're putting the map data into the `geom` part of this call.  This means that we can add additional data to other geoms and plot on top of the map 

```{r}

origin <- data.frame(x = 0, y = 0)

city <- c("Sydney", "Melbourne", "Brisbane", "Perth", "Adelaide")
lon <- c(151.2100, 144.9631, 153.0281, 115.8606, 138.6000)
lat <- c(-33.8678, -37.8142, -27.4678, -31.9559, -34.9275)

capitals <- data.frame(city, lon, lat )

ggplot() +
  geom_polygon(data = world, aes(x = long, y = lat, group = group)) +
  coord_fixed(1.3) +
  geom_point(data = origin, aes(x = x, y = y), col = "red", size = 1)

world_plot <- ggplot() +
  geom_polygon(data = world, aes(x = long, y = lat, group = group)) +
  coord_fixed(1.3)

ggplot() +
  geom_polygon(data = australia, aes(x = long, y= lat, group = group)) +
  coord_fixed(1.3) +
  geom_point(data = capitals, aes(x=lon, y =lat, shape = city), col = 'red', size = 2) 

```

Now here is a new set of data on penguins! 🐧🐧🐧🐧 and maybe some new functions to learn

these are real data from GBIF with all of the features and flaws of real data.  

```{r}
csv_file_name_vector <- list.files("data/penguins/", full.names = TRUE)
# note that this returns the path from the working directory to all the penguin files.
# apparently there are 19 penguin species in the world.  The first one alphabetically is Aptenodytes forsteri
```

https://en.wikipedia.org/wiki/Emperor_penguin


```{r}
a <- read.csv("data/penguins/Aptenodytes forsteri.csv")
a

# Putting all penguins in a list

list_of_data <- list()

aa <- read.csv(csv_file_name_vector[1])
list_of_data[[1]] <- read.csv(csv_file_name_vector[1])
list_of_data[[2]] <- read.csv(csv_file_name_vector[2])

dim(list_of_data[[1]])
dim(list_of_data[[2]])

output_df <- bind_rows(list_of_data)

dim(output_df)
```

Ugh this is gonna take forever ... what about a loop?

```{r}
files <- list.files("data/penguins/", full.names = TRUE)
```

sometimes you want to use the index in the `for` loop for two different things, (1) going through the input vector and (2) storing in the output list. In this case the convention is to use the letter `i`, because it's hard to think of a more informative way to describe these two different (but related) roles.  The vector that `i` goes over is *usually* from 1 to the number of inputs or in this case `1:length(files)`

```{r}
pen <- list()
for (i in 1:length(files)) {
  pen[[i]] <- read_csv(files[i])
}

pen_all <- bind_rows(pen)
dim(pen_all)
```

That's it. you're now all `for` loop experts. Time for practice.  

## More Exercises

1. Filter the data set to only iNaturalist records (see column institutionCode), split by species, and write each species data to a separate file in a folder called `inat_penguins`  You'll also need a function called `paste` or `paste0`

Note in this case the index is only needed for one thing so you can use an informative index.

Here is part of the answer: the line of code for writing the dataframe to a file, with one way to do the naming part.  

```{r}

inat_pen <- list()
inat_pen_df <- filter(pen_all, institutionCode == "iNaturalist") 

for (i in 1:length(unique(pen_all$species))) {
  inat_pen[[i]] <- filter(inat_pen_df, species == unique(inat_pen_df$species)[i])
  write_csv(inat_pen[[i]], paste0("data/", unique(inat_pen_df$species)[i], ".csv"))
}

```

see if you can figure out the rest.  Other functions you might need are `unique` and `filter`, but there are many different solutions

```{r}
#OR

inat_pen <- filter(pen_all, institutionCode == "iNaturalist")
penguin_species <- unique(inat_pen$species)

for(currrent_species in penguin_species){
  curr_df <- filter(inat_pen, species == current_species)
  write_csv(curr_df, paste0("data/",current_species,".csv"))
}

```


2. Calculate how many species, genera, families, and orders there are in this dataset

```{r}

pen_all |>
  summarise(
    n_species = n_distinct(species),
    n_genus = n_distinct(genus),
    n_family= n_distinct(family),
    n_order = n_distinct(order)
  )


```

3. calculate the proportion of points from iNaturalist and eBird using the institutionCode (the code for eBird is confusingly "CLO"; the code for iNaturalist is more sensibly "iNaturalist")

```{r}

sum(pen_all$institutionCode == 'iNaturalist', na.rm = T) / nrow(pen_all)
sum(pen_all$institutionCode == 'CLO', na.rm = T) / nrow(pen_all)

```

4. plot the geographic distribution of observations with the colors showing genus, try to make it look good.  (this blog might help https://sarahpenir.github.io/r/making-maps/)

```{r}
pen_points <-  ggplot() +
  geom_point(data = pen_all, aes(x = decimalLongitude, y = decimalLatitude, col = 'red', size = 1))

pen_all$genus <- as.factor(pen_all$genus)
class(pen_all$genus)

ggplot() +
  geom_polygon(data = world, aes(x = long, y = lat, group = group)) +
  coord_fixed(1.3) +
  geom_point(data = pen_all, na.rm = T, aes(x = decimalLongitude, y = decimalLatitude, col = genus), size = 1) +
  scale_fill_discrete() 

```

5. write a for loop that makes a map of each genus in a separate file with species as the colors.  Save the maps in a folder called `penguin_maps`.  `ggsave` is a handy function.  

```{r}

for(current_genus in unique(pen_all$genus)){
  curr_df <- filter(pen_all, genus == current_genus)
  world <- map_data("world")
  ggplot() +
    geom_polygon(data = world, aes(x = long, y = lat, group = group)) +
    coord_fixed(1.3) +
    geom_point(data = curr_df, na.rm = T,  aes(x = decimalLongitude, y = decimalLatitude, col = 'red'), size = 1) +
    theme_void()
  ggsave(file.path("penguin_maps",paste0(current_genus, ".pdf")))
}


```


6. plot the geographic distribution of observations of more than 1000 penguins, with the colors showing number of penguins observed

```{r}

```


7. find a dubious penguin record and identify who's to blame
```{r}

```

```{r}

```

